# -*- coding: utf-8 -*-
"""NDVI_2025_ANDESwebapp.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1adock6lWrXzLjW-fQEroOf5pdXKn2zV0

# Tratamiento de imagenes con IA
"""

from google.colab import drive
drive.mount('/content/drive')

# Instalar las librerias que no estan por defecto en Google Colab

!pip install sentinelsat
!pip install folium
!pip install descartes
!pip install rasterio
!pip install wget
!pip install geopandas
!pip install pandas

# Importar las librerias

import folium
import os
import numpy as np

from sentinelsat import SentinelAPI, read_geojson, geojson_to_wkt
import geopandas as gpd
import pandas as pd
import numpy as np
import rasterio
import matplotlib.pyplot as plt

from shapely.geometry import MultiPolygon, Polygon
import wget

"""---

## NVDI

## Carga de datos multiespectrales
"""

# Cargamos las imagenes multi-espectrales
filename_band1 = "/content/drive/MyDrive/SENSORES REMOTOS/IMG_0004_1.tif"
filename_band2 = "/content/drive/MyDrive/SENSORES REMOTOS/IMG_0004_2.tif"
filename_band3 = "/content/drive/MyDrive/SENSORES REMOTOS/IMG_0004_3.tif"
filename_band4 = "/content/drive/MyDrive/SENSORES REMOTOS/IMG_0004_4.tif"
filename_band5 = "/content/drive/MyDrive/SENSORES REMOTOS/IMG_0004_5.tif"

band1 = rasterio.open(filename_band1) # Blue
band2 = rasterio.open(filename_band2) # Green
band3 = rasterio.open(filename_band3) # Red
band4 = rasterio.open(filename_band4) # EdgeRed
band5 = rasterio.open(filename_band5) # NIR

band1_array = band1.read(1).astype('float64')
band2_array = band2.read(1).astype('float64')
band3_array = band3.read(1).astype('float64')
band4_array = band4.read(1).astype('float64')
band5_array = band5.read(1).astype('float64')

def cummulativeCountCut(x):
    return (x - np.nanpercentile(x, 2)) / (np.nanpercentile(x, 98) - np.nanpercentile(x, 2))

band1_array_CCC = cummulativeCountCut(band1_array)
band2_array_CCC = cummulativeCountCut(band2_array)
band3_array_CCC = cummulativeCountCut(band3_array)
band4_array_CCC = cummulativeCountCut(band4_array)
band5_array_CCC = cummulativeCountCut(band5_array)

RGB_CCC = np.dstack((band3_array_CCC, band2_array_CCC, band1_array_CCC))

"""**NDVI** = NIR - rojo / NIR + rojo


**NDVI** =(band5_array_CCC-band3_array_CCC) / (band5_array_CCC+band3_array_CCC)
"""

NDVI = (band5_array_CCC-band3_array_CCC) / (band5_array_CCC+band3_array_CCC)
NDVI.shape

NDVI = np.divide(np.subtract(band5_array, band3_array), np.add(band5_array, band3_array))

NDVI_ = np.nan_to_num(NDVI, nan = 0)
NDVI_.shape

plt.imshow(NDVI_, cmap = 'jet')
plt.colorbar()

pip install -U scikit-image

!pip install PyWavelets

from skimage.restoration  import denoise_nl_means, estimate_sigma
from skimage import img_as_float, img_as_ubyte, io

sigma_est = np.mean(estimate_sigma(NDVI_))

denoiseFactor = 10000

denoise = denoise_nl_means(NDVI_,
                            h = denoiseFactor * sigma_est,
                            fast_mode = True,
                            patch_size = 10000,
                            patch_distance = 3)

fig, ax = plt.subplots(1, 2, figsize=(15, 15))
ax[0].imshow(NDVI_)
ax[0].set_title('NDVI (Original)')
ax[1].imshow(denoise)
ax[1].set_title('NDVI (Denoised | Factor = 10000)')

denoise_ubyte = img_as_ubyte(denoise)

plt.imshow(denoise_ubyte)
plt.colorbar()

denoise_ubyte.shape

type(denoise_ubyte)

# Commented out IPython magic to ensure Python compatibility.
# %pip install opencv-python

import cv2

# Save Image
cv2.imwrite('denoise_ubyte.jpg', denoise_ubyte)

plt.hist(denoise.flat, bins = 50)

"""Keep in mind this histogram, because we will use it in the image classification section.

## Mask Image
"""

NDVI_.max()

NDVI_.min()

negativeNDVI = (NDVI_ <= 0.0)

plt.imshow(negativeNDVI)
plt.colorbar()

plt.hist(NDVI_.flat, bins = 50)
plt.axvline(0.25, color='r', ls='--', lw=2)

"""---"""

lowNDVI = cv2.inRange(NDVI_, 0, 0.15)

plt.imshow(lowNDVI)
plt.colorbar()

negativeNDVI = (NDVI_ <= 0.0)
lowNDVI = (NDVI_ > 0.0) & (NDVI_ <= 0.15)
medNDVI = (NDVI_ > 0.15) & (NDVI_ <= 0.20)
goodNDVI = (NDVI_ > 0.20) & (NDVI_ <= 0.30)
highNDVI = (NDVI_ >= 0.30)

# # Alternative using CV2 library
# lowNDVI = cv2.inRange(NDVI_, 0, 0.15)
# medNDVI = cv2.inRange(NDVI_, 0.15, 0.20)
# goodNDVI = cv2.inRange(NDVI_, 0.20, 0.30)
# highNDVI = cv2.inRange(NDVI_, 0.30, 0.60)

fig, ax = plt.subplots(1, 5, figsize=(30, 15))
ax[0].imshow(negativeNDVI)
ax[0].set_title('Negative NDVI')
ax[1].imshow(lowNDVI)
ax[1].set_title('Low NDVI')
ax[2].imshow(medNDVI)
ax[2].set_title('Medium NDVI')
ax[3].imshow(goodNDVI)
ax[3].set_title('Good NDVI')
ax[4].imshow(highNDVI)
ax[4].set_title('High NDVI')

fig, ax = plt.subplots(1, 5, figsize=(30, 20))
ax[0].imshow(negativeNDVI, cmap='Greys')
ax[0].set_title('Negative NDVI')
ax[1].imshow(lowNDVI, cmap='Reds')
ax[1].set_title('Low NDVI')
ax[2].imshow(medNDVI, cmap='Blues')
ax[2].set_title('Medium NDVI')
ax[3].imshow(goodNDVI, cmap='Greens')
ax[3].set_title('Good NDVI')
ax[4].imshow(highNDVI, cmap='Oranges')
ax[4].set_title('High NDVI')

# Combine all images
plt.imshow(lowNDVI, cmap='Reds', alpha = 0.25)
plt.imshow(medNDVI, cmap='Blues', alpha = 0.25)
plt.imshow(goodNDVI, cmap='Greens', alpha = 0.25)
plt.imshow(highNDVI, cmap='Oranges', alpha = 0.25)

# Create a new (blank) image with the same dimensions as the original
allNDVI = np.zeros((denoise_ubyte.shape[0], denoise_ubyte.shape[1], 3))

# Assign specific values
allNDVI[negativeNDVI] = (1, 0, 0) # Red
allNDVI[medNDVI] = (0, 1, 0) # Green
allNDVI[goodNDVI] = (0, 0, 1) # Blue
allNDVI[highNDVI] = (1, 1, 0) # Yellow

# Display the new color-coded image
plt.imshow(allNDVI)

# Clean output results

from scipy import ndimage as nd

negativeNDVI_open = nd.binary_opening(negativeNDVI, np.ones((3,3)))
negativeNDVI_close = nd.binary_closing(negativeNDVI_open, np.ones((3,3)))

medNDVI_open = nd.binary_opening(medNDVI, np.ones((3,3)))
medNDVI_close = nd.binary_closing(medNDVI_open, np.ones((3,3)))

goodNDVI_open = nd.binary_opening(goodNDVI, np.ones((3,3)))
goodNDVI_close = nd.binary_closing(goodNDVI_open, np.ones((3,3)))

highNDVI_open = nd.binary_opening(highNDVI, np.ones((3,3)))
highNDVI_close = nd.binary_closing(highNDVI_open, np.ones((3,3)))

# Create a new (blank) image with the same dimensions as the original
allNDVI_clean = np.zeros((denoise_ubyte.shape[0], denoise_ubyte.shape[1], 3))

# Assign specific values
allNDVI_clean[negativeNDVI_close] = (1, 0, 0) # Red
allNDVI_clean[medNDVI_close] = (0, 1, 0) # Green
allNDVI_clean[goodNDVI_close] = (0, 0, 1) # Blue
allNDVI_clean[highNDVI_close] = (1, 1, 0) # Yellow

# Display the new color-coded image
plt.imshow(allNDVI_clean)

fig, ax = plt.subplots(1, 2, figsize=(15, 15))
ax[0].imshow(allNDVI)
ax[0].set_title('NDVI (Original)')
ax[1].imshow(allNDVI_clean)
ax[1].set_title('NDVI (Cleaned)')

# Save image
plt.imsave('histogramMaskNDVI.jpg', allNDVI_clean)

"""---"""

# Find the image shape
denoise_ubyte.shape

# Reshape the image and convert it into a vector column
denoiseFlat = denoise_ubyte.reshape(-1, 3)

denoiseFlat.shape

denoiseFlat.dtype

"""According [OpenCV documentation](https://docs.opencv.org/3.4/d1/d5c/tutorial_py_kmeans_opencv.html), the data MUST be as `np.float32`."""

denoiseFlat = np.float32(denoiseFlat)

denoiseFlat.dtype

"""## K-Means

In order to implement K-Means in an image, we need to define:
- Number of clusters (k)
- Stop criteria
- Number of attemps
"""

criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 10, 1.0)
k = 4
attemps = 1000

"""The following code will return:
- **Compactness** : It is the sum of squared distance from each point to their corresponding centers.
- **Labels** : This is the label array (same as 'code' in previous article) where each element marked '0', '1'.....
- **Centers** : This is array of centers of clusters.
"""

ret,label,center=cv2.kmeans(denoiseFlat, 4, None, criteria, attemps, cv2.KMEANS_RANDOM_CENTERS)

# Explore output

center.shape

"""We obtain a `(4,3)` tuple, since we specify that the number of clusters is equal to `4`, and the second value corresponds to number of channels in the image.

Now, we can convert the center values to integers in order to plot them:
"""

center = np.uint8(center)

center.shape

"""We can unflatten the labels:"""

label.shape

ndviKNN = center[label.flatten()]

ndviKNN.shape

"""Now, we will assign the dimensions of the (original) in order to show the results of the image:"""

ndviKNN_ = ndviKNN.reshape((denoise.shape))

ndviKNN_.shape

"""Now, we can write the array as an image file ('NDVI_KMeans.jpg')"""

cv2.imwrite('NDVI_KMeans.jpg', ndviKNN_)

plt.imshow(ndviKNN_)

fig, ax = plt.subplots(1, 2, figsize=(15, 15))
ax[0].imshow(NDVI_)
ax[0].set_title('NDVI (Original)')
ax[1].imshow(ndviKNN_)
ax[1].set_title('NDVI K-Means = 4')

plt.hist(denoise_ubyte.flat, bins = 50, alpha = 0.5)
plt.hist(ndviKNN, bins = 50)

np.unique(ndviKNN_)

ndviKNN_class0 = (ndviKNN_ == 4)
ndviKNN_class1 = (ndviKNN_ == 23)
ndviKNN_class2 = (ndviKNN_ == 45)
ndviKNN_class3 = (ndviKNN_ == 77)

# Create a new (blank) image with the same dimensions as the original
allNDVI_KNN = np.zeros((ndviKNN_.shape[0], ndviKNN_.shape[1], 3))

# Assign specific values
allNDVI_KNN[ndviKNN_class0] = (1, 0, 0) # Red
allNDVI_KNN[ndviKNN_class1] = (0, 1, 0) # Green
allNDVI_KNN[ndviKNN_class2] = (0, 0, 1) # Blue
allNDVI_KNN[ndviKNN_class3] = (1, 1, 0) # Yellow

# Display the new color-coded image
plt.imshow(allNDVI_KNN)

"""---

Comparison between Mask  (Histogram) and KNN
"""

fig, ax = plt.subplots(1, 3, figsize=(24, 15))
ax[0].imshow(NDVI_)
ax[0].set_title('NDVI (Original)')
ax[1].imshow(allNDVI)
ax[1].set_title('NDVI Mask (Histogram)')
ax[2].imshow(allNDVI_KNN)
ax[2].set_title('NDVI K-Means = 4')

"""---"""